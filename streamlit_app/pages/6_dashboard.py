import streamlit as st
import pandas as pd
from dotenv import load_dotenv
import os
import json
from datetime import datetime

# Configuration de la page
st.set_page_config(
    page_title="Dashboard Simple - Mod√®les IA",
    page_icon="üìä",
    layout="wide"
)

# Firebase imports
try:
    import firebase_admin
    from firebase_admin import credentials, firestore
    FIREBASE_AVAILABLE = True
except ImportError:
    FIREBASE_AVAILABLE = False
    st.error("‚ùå Firebase non install√©. Installez avec: pip install firebase-admin")

# Chargement des variables d'environnement
load_dotenv()

# ==================== FIREBASE CONFIGURATION ====================

@st.cache_resource
def init_firebase():
    """Initialise la connexion Firebase"""
    if not FIREBASE_AVAILABLE:
        return None
    
    try:
        if firebase_admin._apps:
            return firestore.client()
        
        # M√©thode 1 : Fichier JSON (d√©veloppement local)
        cred_path = os.getenv("FIREBASE_CREDENTIALS_PATH")
        if cred_path and os.path.exists(cred_path):
            cred = credentials.Certificate(cred_path)
        
        # M√©thode 2 : Streamlit Secrets (Streamlit Cloud)
        elif "firebase_credentials" in st.secrets:
            firebase_config = json.loads(st.secrets["firebase_credentials"])
            cred = credentials.Certificate(firebase_config)
        
        # M√©thode 3 : Variables d'environnement individuelles
        else:
            firebase_config = {
                "type": "service_account",
                "project_id": os.getenv("FIREBASE_PROJECT_ID"),
                "private_key_id": os.getenv("FIREBASE_PRIVATE_KEY_ID"),
                "private_key": os.getenv("FIREBASE_PRIVATE_KEY", "").replace('\\n', '\n'),
                "client_email": os.getenv("FIREBASE_CLIENT_EMAIL"),
                "client_id": os.getenv("FIREBASE_CLIENT_ID"),
                "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                "token_uri": "https://oauth2.googleapis.com/token",
                "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
                "client_x509_cert_url": os.getenv("FIREBASE_CLIENT_CERT_URL")
            }
            
            if not all([firebase_config["project_id"], firebase_config["private_key"], firebase_config["client_email"]]):
                st.error("‚ùå Variables Firebase manquantes. V√©rifiez votre configuration.")
                return None
            
            cred = credentials.Certificate(firebase_config)
        
        # Initialiser Firebase
        firebase_admin.initialize_app(cred, {
            'projectId': os.getenv("FIREBASE_PROJECT_ID") or json.loads(st.secrets.get("firebase_credentials", "{}")).get("project_id"),
        })
        
        return firestore.client()
    
    except Exception as e:
        st.error(f"‚ùå Erreur d'initialisation Firebase : {str(e)}")
        return None

@st.cache_data(ttl=30)
def load_all_votes(_db):
    """Charge tous les votes depuis Firebase"""
    if not _db:
        return []
    
    try:
        docs = _db.collection('votes').stream()
        votes = []
        
        for doc in docs:
            data = doc.to_dict()
            
            # Convertir le timestamp Firestore
            if data.get('timestamp') and hasattr(data['timestamp'], 'timestamp'):
                data['timestamp'] = datetime.fromtimestamp(data['timestamp'].timestamp())
            
            votes.append(data)
        
        return votes
    
    except Exception as e:
        st.error(f"‚ùå Erreur chargement votes : {str(e)}")
        return []

def calculate_model_stats(votes_df):
    """Calcule les statistiques par mod√®le"""
    if votes_df.empty:
        return pd.DataFrame()
    
    # Obtenir tous les mod√®les
    all_models = set()
    for _, row in votes_df.iterrows():
        all_models.add(row['model_left'])
        all_models.add(row['model_right'])
    
    stats = []
    
    for model in sorted(all_models):
        # Filtrer les votes o√π ce mod√®le participe
        model_votes = votes_df[
            (votes_df['model_left'] == model) | 
            (votes_df['model_right'] == model)
        ]
        
        # Compteurs de base
        victoires = len(votes_df[votes_df['vote'] == model])
        participations = len(model_votes)
        egalites = len(model_votes[model_votes['vote'] == 'tie'])
        defaites = participations - victoires - egalites
        
        # Calculs de co√ªt, temps et recherches
        cout_total = 0
        temps_total = 0
        recherches_total = 0
        nb_mesures = 0
        
        for _, vote in model_votes.iterrows():
            # R√©cup√©rer les stats selon la position du mod√®le
            stats_model = None
            if vote['model_left'] == model and 'stats_left' in vote and vote['stats_left']:
                stats_model = vote['stats_left']
            elif vote['model_right'] == model and 'stats_right' in vote and vote['stats_right']:
                stats_model = vote['stats_right']
            
            if stats_model:
                cout_total += stats_model.get('total_cost', 0)
                temps_total += stats_model.get('response_time', 0)
                recherches_total += stats_model.get('web_searches', 0)
                nb_mesures += 1
        
        cout_moyen = cout_total / nb_mesures if nb_mesures > 0 else 0
        temps_moyen = temps_total / nb_mesures if nb_mesures > 0 else 0
        recherches_moyennes = recherches_total / nb_mesures if nb_mesures > 0 else 0
        
        stats.append({
            'Mod√®le': model,
            'Victoires': victoires,
            '√âgalit√©s': egalites,
            'D√©faites': defaites,
            'Temps moyen (s)': round(temps_moyen, 2),
            'Co√ªt moyen ($)': f"{cout_moyen:.6f}",
            'Recherches moyennes': round(recherches_moyennes, 1)
        })
    
    return pd.DataFrame(stats).sort_values('Victoires', ascending=False)

def prepare_battles_history(votes_df):
    """Pr√©pare l'historique des battles avec d√©tails complets"""
    if votes_df.empty:
        return pd.DataFrame()
    
    battles = []
    
    for _, vote in votes_df.iterrows():
        # R√©cup√©rer les stats pour chaque mod√®le
        stats_left = vote.get('stats_left', {})
        stats_right = vote.get('stats_right', {})
        
        battle = {
            'Date': vote['timestamp'].strftime('%Y-%m-%d %H:%M:%S') if 'timestamp' in vote and pd.notna(vote['timestamp']) else 'N/A',
            'Mod√®le A': vote['model_left'],
            'Mod√®le B': vote['model_right'],
            'Gagnant': vote['vote'],
            'Question': vote.get('question', 'N/A'),
            'R√©ponse A': vote.get('response_left', 'N/A'),
            'R√©ponse B': vote.get('response_right', 'N/A'),
            'Co√ªt A ($)': f"{stats_left.get('total_cost', 0):.6f}",
            'Co√ªt B ($)': f"{stats_right.get('total_cost', 0):.6f}",
            'Temps A (s)': round(stats_left.get('response_time', 0), 2),
            'Temps B (s)': round(stats_right.get('response_time', 0), 2),
            'Recherches A': stats_left.get('web_searches', 0),
            'Recherches B': stats_right.get('web_searches', 0),
            'Tokens IN A': stats_left.get('input_tokens', 0),
            'Tokens OUT A': stats_left.get('output_tokens', 0),
            'Tokens IN B': stats_right.get('input_tokens', 0),
            'Tokens OUT B': stats_right.get('output_tokens', 0),
            'Utilisateur': vote.get('user_session_id', 'N/A')[:8] + '...' if vote.get('user_session_id') else 'N/A'
        }
        battles.append(battle)
    
    battles_df = pd.DataFrame(battles)
    
    # Trier par date d√©croissante
    if 'Date' in battles_df.columns and battles_df['Date'].iloc[0] != 'N/A':
        battles_df = battles_df.sort_values('Date', ascending=False)
    
    return battles_df

def export_to_txt(data_df, title):
    """Convertit un DataFrame en format texte lisible"""
    txt_content = f"{'='*80}\n{title.upper()}\n{'='*80}\n"
    txt_content += f"G√©n√©r√© le : {datetime.now().strftime('%Y-%m-%d √† %H:%M:%S')}\n"
    txt_content += f"Nombre d'entr√©es : {len(data_df)}\n\n"
    
    for idx, row in data_df.iterrows():
        txt_content += f"{'-'*80}\nENTR√âE #{idx + 1}\n{'-'*80}\n"
        for col, value in row.items():
            txt_content += f"{col}: {value}\n"
        txt_content += "\n"
    
    return txt_content

def export_detailed_battle_to_txt(vote_data):
    """Exporte un battle d√©taill√© en format texte"""
    txt_content = f"{'='*100}\nD√âTAIL COMPLET DU BATTLE\n{'='*100}\n"
    txt_content += f"Date : {vote_data.get('timestamp', 'N/A')}\n"
    txt_content += f"Utilisateur : {vote_data.get('user_session_id', 'N/A')}\n"
    txt_content += f"Gagnant : {vote_data.get('vote', 'N/A')}\n\n"
    
    # Question
    txt_content += f"{'='*50}\nQUESTION\n{'='*50}\n"
    txt_content += f"{vote_data.get('question', 'N/A')}\n\n"
    
    # Mod√®le A (gauche)
    txt_content += f"{'='*50}\nMOD√àLE A : {vote_data.get('model_left', 'N/A')}\n{'='*50}\n"
    stats_left = vote_data.get('stats_left', {})
    txt_content += f"Co√ªt : ${stats_left.get('total_cost', 0):.6f}\n"
    txt_content += f"Temps de r√©ponse : {stats_left.get('response_time', 0):.2f}s\n"
    txt_content += f"Recherches web : {stats_left.get('web_searches', 0)}\n"
    txt_content += f"Tokens input : {stats_left.get('input_tokens', 0)}\n"
    txt_content += f"Tokens output : {stats_left.get('output_tokens', 0)}\n\n"
    txt_content += f"R√âPONSE :\n{'-'*30}\n{vote_data.get('response_left', 'N/A')}\n\n"
    
    # Mod√®le B (droite)
    txt_content += f"{'='*50}\nMOD√àLE B : {vote_data.get('model_right', 'N/A')}\n{'='*50}\n"
    stats_right = vote_data.get('stats_right', {})
    txt_content += f"Co√ªt : ${stats_right.get('total_cost', 0):.6f}\n"
    txt_content += f"Temps de r√©ponse : {stats_right.get('response_time', 0):.2f}s\n"
    txt_content += f"Recherches web : {stats_right.get('web_searches', 0)}\n"
    txt_content += f"Tokens input : {stats_right.get('input_tokens', 0)}\n"
    txt_content += f"Tokens output : {stats_right.get('output_tokens', 0)}\n\n"
    txt_content += f"R√âPONSE :\n{'-'*30}\n{vote_data.get('response_right', 'N/A')}\n\n"
    
    return txt_content

# ==================== INTERFACE PRINCIPALE ====================

st.title("üìä Dashboard Simple - Mod√®les IA")
st.markdown("**Tableau de bord purifi√© avec statistiques essentielles**")

# Bouton d'actualisation
col1, col2 = st.columns([1, 4])
with col1:
    if st.button("üîÑ Actualiser"):
        st.cache_data.clear()
        st.rerun()

# Initialiser Firebase
if FIREBASE_AVAILABLE:
    db = init_firebase()
    
    if db:
        # Charger les donn√©es
        with st.spinner("üì• Chargement des donn√©es..."):
            votes_data = load_all_votes(db)
        
        if votes_data:
            votes_df = pd.DataFrame(votes_data)
            
            # ==================== STATISTIQUES MOD√àLES ====================
            
            st.header("üìä Statistiques par mod√®le")
            
            stats_df = calculate_model_stats(votes_df)
            
            if not stats_df.empty:
                # Afficher le tableau
                st.dataframe(
                    stats_df,
                    use_container_width=True,
                    hide_index=True
                )
                
                # ==================== EXPORT CSV ====================
                
                st.header("üì§ Export")
                
                col_export1, col_export2 = st.columns(2)
                
                with col_export1:
                    # Export statistiques en TXT
                    txt_stats = export_to_txt(stats_df, "Statistiques des Mod√®les IA")
                    st.download_button(
                        label="üìä T√©l√©charger les statistiques (TXT)",
                        data=txt_stats,
                        file_name=f"statistiques_modeles_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt",
                        mime="text/plain",
                        use_container_width=True
                    )
                
                with col_export2:
                    # Export historique en TXT
                    battles_df = prepare_battles_history(votes_df)
                    if not battles_df.empty:
                        txt_battles = export_to_txt(battles_df, "Historique Complet des Battles")
                        st.download_button(
                            label="üìú T√©l√©charger l'historique (TXT)",
                            data=txt_battles,
                            file_name=f"historique_battles_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt",
                            mime="text/plain",
                            use_container_width=True
                        )
                
                # ==================== HISTORIQUE DES BATTLES ====================
                
                st.header("üìú Historique des battles")
                
                battles_df = prepare_battles_history(votes_df)
                
                if not battles_df.empty:
                    # Filtres pour l'historique
                    col_filter1, col_filter2, col_filter3 = st.columns(3)
                    
                    with col_filter1:
                        # Filtre par mod√®le
                        all_models = set(battles_df['Mod√®le A'].tolist() + battles_df['Mod√®le B'].tolist())
                        selected_model = st.selectbox(
                            "Filtrer par mod√®le",
                            ["Tous"] + sorted(list(all_models))
                        )
                    
                    with col_filter2:
                        # Filtre par r√©sultat
                        selected_result = st.selectbox(
                            "Filtrer par r√©sultat",
                            ["Tous", "Victoire", "√âgalit√©"]
                        )
                    
                    with col_filter3:
                        # Nombre d'entr√©es √† afficher
                        nb_entries = st.selectbox(
                            "Nombre d'entr√©es",
                            [10, 25, 50, 100, "Toutes"],
                            index=1
                        )
                    
                    # Appliquer les filtres
                    filtered_battles = battles_df.copy()
                    
                    if selected_model != "Tous":
                        filtered_battles = filtered_battles[
                            (filtered_battles['Mod√®le A'] == selected_model) |
                            (filtered_battles['Mod√®le B'] == selected_model)
                        ]
                    
                    if selected_result == "√âgalit√©":
                        filtered_battles = filtered_battles[filtered_battles['Gagnant'] == 'tie']
                    elif selected_result == "Victoire":
                        filtered_battles = filtered_battles[filtered_battles['Gagnant'] != 'tie']
                    
                    # Limiter le nombre d'entr√©es
                    if nb_entries != "Toutes":
                        filtered_battles = filtered_battles.head(nb_entries)
                    
                    # Afficher l'historique filtr√© avec colonnes suppl√©mentaires
                    st.dataframe(
                        filtered_battles,
                        use_container_width=True,
                        hide_index=True,
                        column_config={
                            "Date": st.column_config.TextColumn("üìÖ Date", width="medium"),
                            "Mod√®le A": st.column_config.TextColumn("ü§ñ Mod√®le A", width="small"),
                            "Mod√®le B": st.column_config.TextColumn("ü§ñ Mod√®le B", width="small"),
                            "Gagnant": st.column_config.TextColumn("üèÜ Gagnant", width="small"),
                            "Question": st.column_config.TextColumn("‚ùì Question", width="large"),
                            "Co√ªt A ($)": st.column_config.TextColumn("üí∞ Co√ªt A", width="small"),
                            "Co√ªt B ($)": st.column_config.TextColumn("üí∞ Co√ªt B", width="small"),
                            "Temps A (s)": st.column_config.NumberColumn("‚è±Ô∏è Temps A", width="small"),
                            "Temps B (s)": st.column_config.NumberColumn("‚è±Ô∏è Temps B", width="small"),
                            "Recherches A": st.column_config.NumberColumn("üîç Rech. A", width="small"),
                            "Recherches B": st.column_config.NumberColumn("üîç Rech. B", width="small"),
                            "Utilisateur": st.column_config.TextColumn("üë§ User", width="small")
                        }
                    )
                    
                    # Section d'export de battle individuel
                    st.markdown("---")
                    st.subheader("üìã Export d√©taill√© d'un battle sp√©cifique")
                    
                    if not filtered_battles.empty:
                        # S√©lection d'un battle sp√©cifique
                        battle_options = []
                        for idx, battle in filtered_battles.iterrows():
                            option_text = f"{battle['Date']} - {battle['Mod√®le A']} vs {battle['Mod√®le B']} (Gagnant: {battle['Gagnant']})"
                            battle_options.append((option_text, idx))
                        
                        selected_battle = st.selectbox(
                            "Choisir un battle √† exporter en d√©tail",
                            options=[opt[0] for opt in battle_options],
                            index=0
                        )
                        
                        # Trouver l'index du battle s√©lectionn√©
                        selected_idx = None
                        for opt_text, idx in battle_options:
                            if opt_text == selected_battle:
                                selected_idx = idx
                                break
                        
                        if selected_idx is not None:
                            # R√©cup√©rer les donn√©es compl√®tes du vote
                            vote_data = votes_data[selected_idx]
                            
                            col_detail1, col_detail2 = st.columns(2)
                            
                            with col_detail1:
                                # Aper√ßu du battle s√©lectionn√©
                                st.markdown("**üìã Aper√ßu du battle s√©lectionn√© :**")
                                st.write(f"**Date :** {vote_data.get('timestamp', 'N/A')}")
                                st.write(f"**Mod√®les :** {vote_data.get('model_left', 'N/A')} vs {vote_data.get('model_right', 'N/A')}")
                                st.write(f"**Gagnant :** {vote_data.get('vote', 'N/A')}")
                                
                                # Stats rapides
                                stats_left = vote_data.get('stats_left', {})
                                stats_right = vote_data.get('stats_right', {})
                                st.write(f"**Co√ªts :** ${stats_left.get('total_cost', 0):.6f} vs ${stats_right.get('total_cost', 0):.6f}")
                                st.write(f"**Temps :** {stats_left.get('response_time', 0):.2f}s vs {stats_right.get('response_time', 0):.2f}s")
                            
                            with col_detail2:
                                # Export du battle d√©taill√©
                                detailed_txt = export_detailed_battle_to_txt(vote_data)
                                st.download_button(
                                    label="üìÑ Exporter ce battle en d√©tail (TXT)",
                                    data=detailed_txt,
                                    file_name=f"battle_detail_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt",
                                    mime="text/plain",
                                    use_container_width=True
                                )
                                
                                # Affichage des r√©ponses tronqu√©es
                                st.markdown("**üëÅÔ∏è Aper√ßu des r√©ponses :**")
                                response_a = vote_data.get('response_left', 'N/A')
                                response_b = vote_data.get('response_right', 'N/A')
                                
                                if len(response_a) > 200:
                                    response_a = response_a[:200] + "..."
                                if len(response_b) > 200:
                                    response_b = response_b[:200] + "..."
                                
                                st.text_area(f"R√©ponse {vote_data.get('model_left', 'A')}", response_a, height=100, disabled=True)
                                st.text_area(f"R√©ponse {vote_data.get('model_right', 'B')}", response_b, height=100, disabled=True)
                    
                    # Statistiques rapides de l'historique filtr√©
                    if not filtered_battles.empty:
                        st.markdown("---")
                        col_hist1, col_hist2, col_hist3, col_hist4 = st.columns(4)
                        
                        with col_hist1:
                            st.metric("üìä Battles affich√©es", len(filtered_battles))
                        
                        with col_hist2:
                            egalites_filtrees = len(filtered_battles[filtered_battles['Gagnant'] == 'tie'])
                            st.metric("‚öñÔ∏è √âgalit√©s", egalites_filtrees)
                        
                        with col_hist3:
                            utilisateurs_uniques = filtered_battles['Utilisateur'].nunique()
                            st.metric("üë• Utilisateurs", utilisateurs_uniques)
                        
                        with col_hist4:
                            if selected_model != "Tous":
                                victories_model = len(filtered_battles[filtered_battles['Gagnant'] == selected_model])
                                st.metric(f"üèÜ Victoires {selected_model}", victories_model)
                
                else:
                    st.info("üí° Aucun historique de battles disponible")
            
            else:
                st.warning("‚ö†Ô∏è Aucune statistique disponible")
        
        else:
            st.warning("‚ö†Ô∏è Aucun vote dans la base de donn√©es")
            st.info("üí° Utilisez d'abord l'app de comparaison pour g√©n√©rer des votes")
    
    else:
        st.error("‚ùå Connexion Firebase √©chou√©e")

else:
    st.error("‚ùå Firebase non disponible")
    st.info("üí° Installez Firebase : `pip install firebase-admin`")

# ==================== FOOTER ====================

st.markdown("---")
st.markdown(f"""
<div style='text-align: center; color: #666; font-size: 0.8em;'>
    <p>üìä Dashboard Simple - Derni√®re mise √† jour : {datetime.now().strftime('%H:%M:%S')}</p>
</div>
""", unsafe_allow_html=True)